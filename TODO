[10.10.25]

* Кэшировать результат token_match_cb в negative cache.
* Оптимизировать предварительный этап (токенизацию) - пока некритично, но потом
  придётся делать.


[10.10.24]

* Перевести checkpoint'ы на vstack;       \
* Перевести cancellables на vstack/vslab; /-> Это должно дать ~ + 20%
* Аккуратно реализовать forward optimization [DONE];
* Обосновать алгоритмическую сложность разбора: как ещё можно оптимизировать?


[10.10.04]

Реализованы все запланированные оптимизации: восходящая, негативный кэш и
быстрые переходы. Для быстрых переходов ещё не сделаны фунции условия перехода.

Далее делаю:
    0) Исправить баг с const (7.cpp) (DONE);
    1) Разбор typedef + дамп typedef (DONE);
    2) Разбор шаблонов;
    3) Дамп зависимостей.

Вынесенные определения методов не прикрепляются к исходным member'ам (8.cpp).

Много ошибок в 3.cpp - возможно, связано с оптимизациями? (DONE)
+ в 3.cpp есть неоднозначность по объявлению/вызову функции (DONE).

Нужно сделать дамп инициализаторов.


[10.09.13]

Реализованы восходящая оптимизация (псевдооптимизация, позволившая существенно
сократить отладочную выдачу), негативная нисходящая оптимизация. На очереди:

* inline match functions (DONE);
* Позитивная нисходящая оптимизация: явные переходы с jump-функциями.
  Задача jump-функции - скопировать результат разбора исходной грамматики
  в структуру для новой грамматики.
  Нужно две функции: одна определяет, нужно ли осуществлять переход,
  другая выполняет переход.
  jump-функция принимает на вход массивы структур результатов разбора,
  чтобы заполнение для всех грамматик на пути перехода (RETHOUGHT).


[10.09.06]

Callback'и для условного нисходящего перехода (в основном для закрытия opt/не opt).
Можно ли контролировать opt/не opt в автоматическом режиме?


[10.08.30]

Первые компактные тесты уже позволили упорядочить реализацию мелких деталей
(реализован defined() в препроцессоре).

Результат работы парсера подаётся на вход семантического анализатора.
При этом, поскольку на выходе хотим получить код на C++ (желательно,
максимально близкий к исходному). Поэтому формат выхода семантического
анализатора совпадает с форматом выхода парсера. Семантический анализатор
дополняет результат разбора программы дополнительной информацией: неявными
действиями (преобразования типов, вызов деструкторов) и конкретизацией
(разрешение вызовов виртуальных функций и т.п.).


[10.08.29]

Определяю roadmap.

Что есть:
    * Генератор парсеров pargen (без оптимизаций);
    * Препроцессор реализован на 90%;
    * Конечное внутреннее представление, в основном, сформулировано;
    * Отработаны методы работы с грамматикой C++;
    * Отработаны методы разрешения ряда неоднозначностей;
    * Начата реализация парсера;
    * Начата реализация компилируемого дампа (обратного кодогенератора).

Чего нет:
    * Нет поддержки шаблонов - только предварительные идеи о том,
      как это будет работать;
    * Обратный кодогенератор неполон (реализация только начата);
    * pargen не оптимизирован;
    * Сам парсер неполон;
    * Нет восстановления после ошибок и нормальных сообщений об ошибках
      (совсем).

Цель разработки парсера (что нужно получить):
    * Парсер, генерирующий внутреннее представление для любой программы на C++,
      написанной в соответствии со стандартом ISO C++ 2003-го года;
    * Кодогенератор, формирующий компилируемый код на C++ по любому корректному
      внутреннему представлению.

Связь между парсером и кодогенератором:
    * На этапе разработки парсера кодогенератор нужен для отладки.
          - это означает, что, пока парсер не завершён, нет смысла вылизывать
	    кодогенератор, потому что внутреннее представление может измениться.

От парсера требуется полное покрытие стандарта C++. Каким образом проверять
покрытие?
    * В минимальном варианте - необходим набор тестов, результат обработки
      которых оценивается ручной проверкой.

Наиболее эффективный способ приблизиться к полному покрытию - выписывать тесты,
требующие поддержки нереализованных функций и выполнять доработку парсера
и кодогенератора по этим тестам.

НО: Абсолютно полное и корректное покрытие - плохая цель. Она труднодостижима,
очень трудоёмка и сама по себе бесполезна. Реальная цель - это создание
системы статического анализа программ. Именно к выполнению этой задачи
должна быть привязана разработка парсера и кодогенератора.

Выводы:
    1. Разработка парсера и кодогенератора в ближайшее время будет отталкиваться
       от компактных тестов;
    2. Парсер и кодогенератор развиваются параллельно, причём кодогенератор
       пишется вторым темпом;
    3. Нужно как можно раньше приступить к реализации системы статического
       анализа исходных кодов.

