==== Заметки по реализации транслятора из M в C ====

Возможности, добавляемые к C:
* Аннотирование;
* M-объекты, S-объекты;
* Конструктор по умолчанию для M-объектов, деструкторы;
* Ссылки и слабые ссылки;
* parent-объекты (простейшее наследование);
* Методы M-объектов, синхронные и асинхронные;
* Оператор call;
* Асинхронные цепочки;
* События (Cond).

Из них наиболее важные:
* M-объекты (MT-safe) с синхронными и асинхронными методами;
* Аннотирование;
* Асинхронные цепочки;
* Механизм подсчёта ссылок, встроенный в язык;
* Возможности из C++ в ограниченном варианте: шаблоны, деструкторы.

=== Порядок первоначальной реализации ===

1. M- и S-объекты;

2. Ссылки и слабые ссылки;

3. Методы синхронные и асинхронные, оператор call;

4. Конструкторы и деструкторы M- и S-объектов;

5. Асинхронные цепочки.

Вторичная реализация добавит:
    * аннотирование;
    * события.

=== Реализация M- и S-объектов ===

1. Завожу отдельный файл реализации для фич, специфичных для M (mt_parser.cpp);
2. Нужна поддержка статичечких условий в pargen, чтобы выделить специфичные для
   Mt участки грамматики. На первое время не отвлекаюсь и использую отдельную
   грамматику (mat.par);
3. В грамматику добавляю новые элементы (MAsyncObject, MObject);
4. В namespace Cpp под условную компиляцию добавляю MAsyncObject и MObject как
   разновидность классов. Условные конструкции не должны влиять на работу
   парсера чистого C++, независимо от того, включены они или нет;
5. Выписываю функции формирования внутреннего представления M- и S- объектов
   для парсера (в mt_parser.cpp);
6. (на этом этапе имею полноценное внутреннее представление object на выходе
   парсера)
   Реализую обход деклараций в единице трансляции с преобразованием
   Mt-конструкций в конструкции C. Преобразование выполняется в момент
   формирования результирующего .cpp-файла (mt_translator.cpp), то есть в момент
   дампа. Транслятор опирается на DumpContext.

